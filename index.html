<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FPS — Animated Hands (Improved Jump)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,Arial}
    #overlay{position:absolute;left:12px;top:12px;z-index:20;color:#fff;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:8px}
    #fps{position:absolute;right:12px;top:12px;z-index:20;color:#7cff7c;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:8px;font-family:monospace}
    #crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:18px;height:18px;z-index:15;pointer-events:none}
    #crosshair:before,#crosshair:after{content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:2px;height:10px;background:rgba(255,255,255,0.95)}
    #crosshair:after{transform:translate(-50%,-50%) rotate(90deg)}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="overlay"><strong>FPS — Animated Hands</strong><div style="font-size:13px;margin-top:6px">Click to lock pointer. Move: W A S D · Jump: Space · Run: Shift</div></div>
  <div id="fps">FPS: --</div>
  <div id="crosshair"></div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';

/* -------------------------
   Basic scene (kept simple)
   ------------------------- */
const scene = new THREE.Scene();
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 1.4));
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);
window.addEventListener('resize', ()=> {
  camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* Camera rig visual (slerp rotation) */
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const cameraHolder = new THREE.Object3D();
cameraHolder.add(camera);
scene.add(cameraHolder);

let yaw = 0, pitch = 0;
const sensitivity = 0.0023;
const pitchLimit = Math.PI/2 - 0.01;

/* Lighting & sky */
const hemi = new THREE.HemisphereLight(0x87ceeb, 0x222244, 0.7); scene.add(hemi);
const sun = new THREE.DirectionalLight(0xffffff, 1.0); sun.castShadow = true;
sun.shadow.mapSize.set(512,512); sun.shadow.camera.near=0.5; sun.shadow.camera.far=300;
sun.shadow.camera.left=-60; sun.shadow.camera.right=60; sun.shadow.camera.top=60; sun.shadow.camera.bottom=-60;
scene.add(sun);
const sunMesh = new THREE.Mesh(new THREE.SphereGeometry(1.6,12,8), new THREE.MeshBasicMaterial({color:0xfff0c8,toneMapped:false}));
const moonMesh = new THREE.Mesh(new THREE.SphereGeometry(1.2,10,8), new THREE.MeshBasicMaterial({color:0xdde6ff,toneMapped:false}));
scene.add(sunMesh, moonMesh);
let timeOfDay = 0.32;
function updateSun(t){
  const a = t * Math.PI * 2;
  const dir = new THREE.Vector3(Math.cos(a), Math.sin(a), Math.sin(a*0.6)).normalize();
  sun.position.copy(dir.clone().multiplyScalar(120));
  sun.target.position.set(0,0,0); sun.target.updateMatrixWorld();
  sunMesh.position.copy(dir.clone().multiplyScalar(120));
  moonMesh.position.copy(dir.clone().multiplyScalar(-80));
  const day = new THREE.Color(0x87ceeb), night = new THREE.Color(0x0b1220);
  const f = THREE.MathUtils.smoothstep(Math.sin(a), -0.2, 0.6);
  renderer.setClearColor(night.clone().lerp(day, f));
  hemi.intensity = THREE.MathUtils.lerp(0.08,0.9, Math.max(0, Math.sin(a)));
  sun.intensity = THREE.MathUtils.lerp(0.15,1.4, Math.max(0, Math.sin(a)));
}

/* World */
const ground = new THREE.Mesh(new THREE.BoxGeometry(500,1,500), new THREE.MeshStandardMaterial({color:0x55664f}));
ground.position.y=-0.5; ground.receiveShadow = true; scene.add(ground);
const grid = new THREE.GridHelper(200,40,0x444444,0x333333); grid.position.y = 0.01; scene.add(grid);

const platforms = [];
function makePlatform(x,y,z,sx=6,sy=1,sz=6,color=0x8b7d6b){
  const m = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), new THREE.MeshStandardMaterial({color}));
  m.position.set(x,y,z); m.castShadow=true; m.receiveShadow=true; scene.add(m);
  platforms.push({mesh:m, half:new THREE.Vector3(sx/2,sy/2,sz/2)});
}
makePlatform(0,2,10,8,1,8,0x8b7d6b);
makePlatform(8,4,18,6,1,6,0x7fa0a0);
makePlatform(-8,6,26,4,1,10,0x6a8b8b);

/* Player collider & movement (Valve-style bhop) */
const player = {
  height:1.8, radius:0.35,
  pos:new THREE.Vector3(0,1.8,30),
  vel:new THREE.Vector3(),
  speed:6, runMul:1.8, jumpSpeed:7.3, onGround:false
};
cameraHolder.position.copy(player.pos);

function colliderCenter(pos,out=new THREE.Vector3()){ return out.set(pos.x,pos.y - (player.height/2 - player.radius), pos.z); }
function colliderHalf(){ return new THREE.Vector3(player.radius, player.height/2, player.radius); }
function aabbOverlap(aC,aH,bC,bH){
  const dx=aC.x-bC.x, px=(aH.x+bH.x)-Math.abs(dx); if(px<=0) return null;
  const dy=aC.y-bC.y, py=(aH.y+bH.y)-Math.abs(dy); if(py<=0) return null;
  const dz=aC.z-bC.z, pz=(aH.z+bH.z)-Math.abs(dz); if(pz<=0) return null;
  const overlap=new THREE.Vector3();
  if(px<py && px<pz) overlap.x = dx>0?px:-px;
  else if(py<px && py<pz) overlap.y = dy>0?py:-py;
  else overlap.z = dz>0?pz:-pz;
  return overlap;
}

/* Controls */
const input = {f:0,b:0,l:0,r:0, run:0, jumpHeld:false};
let jumpRequested=false, jumpBuffer=0, maxJumpBuffer=0.14;
window.addEventListener('keydown', e=>{ if(e.code==='KeyW') input.f=1; if(e.code==='KeyS') input.b=1; if(e.code==='KeyA') input.l=1; if(e.code==='KeyD') input.r=1; if(e.code==='ShiftLeft'||e.code==='ShiftRight') input.run=1; if(e.code==='Space'){ input.jumpHeld=true; jumpRequested=true; jumpBuffer=maxJumpBuffer }});
window.addEventListener('keyup', e=>{ if(e.code==='KeyW') input.f=0; if(e.code==='KeyS') input.b=0; if(e.code==='KeyA') input.l=0; if(e.code==='KeyD') input.r=0; if(e.code==='ShiftLeft'||e.code==='ShiftRight') input.run=0; if(e.code==='Space'){ input.jumpHeld=false; jumpRequested=false }});

let pointerLocked=false;
document.addEventListener('mousemove', e=>{
  if(!pointerLocked) return;
  yaw -= e.movementX * sensitivity;
  pitch -= e.movementY * sensitivity;
  pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));
});
renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
document.addEventListener('pointerlockchange', ()=> { pointerLocked = document.pointerLockElement === renderer.domElement; document.getElementById('overlay').style.opacity = pointerLocked ? '0.6' : '1'; });

/* Particles (simple) */
const MAX_P = 64; const Ppos = new Float32Array(MAX_P*3); const Pvel = new Float32Array(MAX_P*3); const Plife = new Float32Array(MAX_P);
for(let i=0;i<MAX_P;i++){Ppos[i*3]=Ppos[i*3+1]=Ppos[i*3+2]=9999; Plife[i]=0;}
const pGeo = new THREE.BufferGeometry(); pGeo.setAttribute('position', new THREE.BufferAttribute(Ppos,3));
const pMat = new THREE.PointsMaterial({size:0.09, transparent:true, opacity:0.85, depthWrite:false});
const pSys = new THREE.Points(pGeo, pMat); pSys.frustumCulled = false; scene.add(pSys);
let pTimer=0, pInterval=0.24;
function spawnP(x,y,z,vx,vy,vz,life=0.9){ for(let i=0;i<MAX_P;i++){ if(Plife[i]<=0){ const pi=i*3; Ppos[pi]=x; Ppos[pi+1]=y; Ppos[pi+2]=z; Pvel[pi]=vx; Pvel[pi+1]=vy; Pvel[pi+2]=vz; Plife[i]=life; return; } } }

/* ----------------------------
   HANDS: model + animation system
   ---------------------------- */

/* Hand model:
   - hands Group attached to camera
   - each hand: palm (box) + 3 finger boxes (simple)
   - hands centered horizontally (x=0), Y base kept as user wanted
   - animation states: idle / walk / jump / fall / land
*/

const handsRoot = new THREE.Object3D();
camera.add(handsRoot);
// center horizontally, keep Y roughly the same
handsRoot.position.set(0, -0.28, -0.48);

const handMaterial = new THREE.MeshStandardMaterial({ color: 0xd6b07a });

function makeHand(isLeft){
  const group = new THREE.Object3D();
  // palm
  const palm = new THREE.Mesh(new THREE.BoxGeometry(0.28,0.24,0.46), handMaterial);
  palm.position.set(isLeft ? -0.36 : 0.36, 0, 0.06);
  group.add(palm);
  // fingers (three simple boxes)
  const fingers = new THREE.Group();
  fingers.position.set(palm.position.x, palm.position.y + 0.06, palm.position.z + 0.18);
  for (let i=0;i<3;i++){
    const f = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,0.18), handMaterial);
    f.position.set((i-1)*0.07, 0, 0);
    f.castShadow = true; f.receiveShadow = true;
    fingers.add(f);
  }
  group.add(fingers);
  // slightly rotate palms so they look natural when centered
  group.rotation.y = isLeft ? 0.08 : -0.08;
  return { group, palm, fingers };
}

const left = makeHand(true);
const right = makeHand(false);
handsRoot.add(left.group, right.group);

// base positions / rotations to lerp back to
const baseHandsPos = handsRoot.position.clone();
const baseLeftRotZ = left.palm.rotation.z, baseRightRotZ = right.palm.rotation.z;
left.group.rotation.set(0, 0.08, 0);
right.group.rotation.set(0, -0.08, 0);

/* Animation state machine */
let handState = 'idle'; // 'idle' | 'walk' | 'jump' | 'fall' | 'land'
let prevOnGround = true;
let landTimer = 0;
let stateBlend = 1.0; // blending coefficient for transitions (0..1)
let stateBlendTarget = 1.0;

/* small internal timers for walk bob */
let walkPhase = 0;

/* Update hand animation state based on player movement & vertical velocity */
function computeHandState(dt){
  // detect transitions
  if (!player.onGround){
    if (player.vel.y > 0.9) {
      if (handState !== 'jump') { handState = 'jump'; stateBlend = 0; stateBlendTarget = 1; }
    } else if (player.vel.y < -0.9) {
      if (handState !== 'fall') { handState = 'fall'; stateBlend = 0; stateBlendTarget = 1; }
    } else {
      // small in-air near apex -> treat as fall if negative velo otherwise jump
      if (player.vel.y > 0.2) { if (handState !== 'jump') { handState='jump'; stateBlend=0; stateBlendTarget=1; } }
      else { if (handState !== 'fall') { handState='fall'; stateBlend=0; stateBlendTarget=1; } }
    }
  } else {
    // on ground -> if we just landed, trigger land state briefly
    if (!prevOnGround && player.onGround){
      handState = 'land'; landTimer = 0; stateBlend = 0; stateBlendTarget = 1;
    } else {
      // walking vs idle
      const speedXZ = Math.hypot(player.vel.x, player.vel.z);
      if (speedXZ > 0.3) {
        if (handState !== 'walk') { handState = 'walk'; stateBlend = 0; stateBlendTarget = 1; }
      } else {
        if (handState !== 'idle') { handState = 'idle'; stateBlend = 0; stateBlendTarget = 1; }
      }
    }
  }
  prevOnGround = player.onGround;
  // advance land timer if in land state
  if (handState === 'land'){
    landTimer += dt;
    if (landTimer > 0.18) { // land state ends quickly
      handState = 'idle';
      stateBlend = 0; stateBlendTarget = 1;
    }
  }
  // advance blend toward target (smooth transitions)
  stateBlend = THREE.MathUtils.lerp(stateBlend, stateBlendTarget, Math.min(1, 7 * dt));
}

/* Compute animation targets per state and apply smoothing + sway blending */
let prevCameraQ = cameraHolder.quaternion.clone();
function updateHands(dt){
  computeHandState(dt);

  // base sway from camera angular delta (same technique as earlier)
  const curQ = cameraHolder.quaternion;
  const dq = prevCameraQ.clone().conjugate().multiply(curQ).normalize();
  prevCameraQ.copy(curQ);
  const angle = 2 * Math.acos(Math.max(-1, Math.min(1, dq.w)));
  let swayX = 0, swayZ = 0, swayRot = 0;
  if (angle > 1e-6){
    const s = Math.sin(angle/2) || 1e-6;
    const ax = dq.x / s, ay = dq.y / s;
    // stronger sway than before but we will blend with states
    swayX = ay * angle * 0.9;
    swayZ = ax * angle * 0.9;
    swayRot = ay * angle * 1.6;
  }

  // derive state-based targets
  // default target values (neutral)
  const target = {
    pos: baseHandsPos.clone(),
    rotLeftZ: baseLeftRotZ,
    rotRightZ: baseRightRotZ,
    leftPalmRotX: 0,
    rightPalmRotX: 0,
    fingersCurl: 0 // 0=open, 1=curled
  };

  // walking bob (small up/down + rotation) - uses walkPhase
  const speedXZ = Math.hypot(player.vel.x, player.vel.z);
  if (handState === 'walk'){
    const bobSpeed = THREE.MathUtils.lerp(6.0, 10.5, Math.min(1, speedXZ / (player.speed * 1.2)));
    walkPhase += dt * bobSpeed * 1.4;
    const bobY = Math.sin(walkPhase) * 0.03; // small vertical bob
    const bobX = Math.sin(walkPhase * 0.6) * 0.02;
    target.pos.y += bobY * 0.8; // very small vertical
    target.pos.x += bobX * 0.3;
    // small rotation during walk
    target.rotLeftZ += Math.sin(walkPhase * 0.9) * 0.06;
    target.rotRightZ += Math.cos(walkPhase * 0.9) * 0.06;
    target.fingersCurl = 0.15; // slight curl while walking
  } else if (handState === 'idle'){
    // idle breathing: tiny up/down + fingers small motion
    walkPhase += dt * 0.8;
    target.pos.y += Math.sin(walkPhase) * 0.01;
    target.fingersCurl = 0.05;
  } else if (handState === 'jump'){
    // IMPORTANT: reduce vertical translation on jump to prevent seeing entire block.
    // use rotation-based jump pose and very small upward translation (clamped).
    target.pos.y += 0.02; // minimal lift only
    target.leftPalmRotX = -0.45; // rotate palms slightly upward
    target.rightPalmRotX = -0.45;
    target.fingersCurl = 0.05;
    // subtle outward rotate
    target.rotLeftZ += 0.25;
    target.rotRightZ -= 0.25;
  } else if (handState === 'fall'){
    // when falling, tilt hands down a bit so they don't pop up
    target.pos.y -= 0.02; // slight downwards
    target.leftPalmRotX = 0.25;
    target.rightPalmRotX = 0.25;
    target.fingersCurl = 0.02;
    target.rotLeftZ += 0.12;
    target.rotRightZ -= 0.12;
  } else if (handState === 'land'){
    // landing recoil: short downward then settle
    const t = Math.min(1, landTimer / 0.18);
    // quick negative Y (hands go down slightly), then small settle
    target.pos.y -= 0.06 * (1 - Math.pow(1 - t, 2));
    target.leftPalmRotX = 0.35 * (1 - t);
    target.rightPalmRotX = 0.35 * (1 - t);
    target.fingersCurl = 0.02 + 0.18 * (1 - t);
  }

  // apply camera-sway on top, but attenuate during jump/fall/land to avoid popping
  const swayAttenuation = (handState === 'jump' || handState === 'fall' || handState === 'land') ? 0.4 : 1.0;
  const appliedSwayX = swayX * 0.85 * swayAttenuation;
  const appliedSwayZ = swayZ * 0.7 * swayAttenuation;
  const appliedSwayRot = swayRot * 0.85 * swayAttenuation;

  // combine state target + sway
  const finalPos = target.pos.clone();
  finalPos.x += appliedSwayX * 0.18;
  finalPos.z += appliedSwayZ * 0.12;

  // blend/smooth towards final transform
  const lerpT = THREE.MathUtils.clamp(0.12 + 0.6 * stateBlend, 0.02, 0.45); // faster blend when stateBlend close to 1
  handsRoot.position.x = THREE.MathUtils.lerp(handsRoot.position.x, finalPos.x, lerpT);
  handsRoot.position.y = THREE.MathUtils.lerp(handsRoot.position.y, finalPos.y, lerpT);
  handsRoot.position.z = THREE.MathUtils.lerp(handsRoot.position.z, finalPos.z, lerpT);

  // rotate palms around X for jump/fall, and rotate Z for outward/inward
  // left palm
  left.group.rotation.x = THREE.MathUtils.lerp(left.group.rotation.x, target.leftPalmRotX || 0, lerpT * 1.1);
  left.palm.rotation.z = THREE.MathUtils.lerp(left.palm.rotation.z, target.rotLeftZ + appliedSwayRot*0.4, lerpT * 0.85);
  // right palm
  right.group.rotation.x = THREE.MathUtils.lerp(right.group.rotation.x, target.rightPalmRotX || 0, lerpT * 1.1);
  right.palm.rotation.z = THREE.MathUtils.lerp(right.palm.rotation.z, target.rotRightZ - appliedSwayRot*0.4, lerpT * 0.85);

  // fingers curling: lerp each finger rotation (simple) — fingers are in child group index
  const curl = THREE.MathUtils.lerp(0, target.fingersCurl, lerpT);
  for (let i=0;i<left.group.children.length;i++){
    const c = left.group.children[i];
    if (c.type === 'Group'){ // fingers group
      for (let j=0;j<c.children.length;j++){
        c.children[j].rotation.x = THREE.MathUtils.lerp(c.children[j].rotation.x, -curl * 0.8, lerpT);
      }
    }
  }
  for (let i=0;i<right.group.children.length;i++){
    const c = right.group.children[i];
    if (c.type === 'Group'){
      for (let j=0;j<c.children.length;j++){
        c.children[j].rotation.x = THREE.MathUtils.lerp(c.children[j].rotation.x, -curl * 0.8, lerpT);
      }
    }
  }
}

/* -------------------------
   Physics (Valve-style BHop)
   ------------------------- */
const GRAV = -20.0;
function physicsStep(dt){
  if (jumpBuffer > 0) jumpBuffer -= dt;
  const f = input.f - input.b;
  const s = input.r - input.l;
  const run = input.run ? player.runMul : 1;
  const maxSpeed = player.speed * run;
  // orientation yaw-only
  const fw = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw).setY(0).normalize();
  const rt = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw).setY(0).normalize();
  const wish = new THREE.Vector3(); wish.addScaledVector(fw,f); wish.addScaledVector(rt,s);
  const wishlen = wish.length(); const wishdir = wishlen>0 ? wish.normalize() : new THREE.Vector3();

  if (player.onGround){
    // friction
    const friction = 8.0;
    const sp = Math.hypot(player.vel.x, player.vel.z);
    if (sp > 0.001){
      const drop = sp * friction * dt;
      const newsp = Math.max(0, sp - drop);
      const sc = newsp / Math.max(sp, 1e-6);
      player.vel.x *= sc; player.vel.z *= sc;
    }
    if (wishlen > 0){
      const wishspeed = maxSpeed;
      const accel = 100.0;
      const curr = player.vel.x * wishdir.x + player.vel.z * wishdir.z;
      const addspeed = wishspeed - curr;
      if (addspeed > 0){
        let accelspeed = accel * dt * wishspeed;
        if (accelspeed > addspeed) accelspeed = addspeed;
        player.vel.x += wishdir.x * accelspeed;
        player.vel.z += wishdir.z * accelspeed;
      }
    }
    if ((jumpRequested || jumpBuffer > 0 || input.jumpHeld) && player.onGround){
      player.vel.y = player.jumpSpeed; player.onGround = false; jumpRequested = false; jumpBuffer = 0;
    }
  } else {
    if (wishlen > 0){
      const wishspeed = maxSpeed;
      const curr = player.vel.x * wishdir.x + player.vel.z * wishdir.z;
      let addspeed = wishspeed - curr;
      if (addspeed > 0){
        const airAccel = 10.5;
        let accelspeed = airAccel * dt * wishspeed;
        if (accelspeed > addspeed) accelspeed = addspeed;
        player.vel.x += wishdir.x * accelspeed;
        player.vel.z += wishdir.z * accelspeed;
      }
    }
    // cap
    const hs = Math.hypot(player.vel.x, player.vel.z);
    const maxAir = Math.max(maxSpeed * 2.6, player.speed * 2.6);
    if (hs > maxAir){ const s = maxAir / hs; player.vel.x *= s; player.vel.z *= s; }
    player.vel.x *= 0.9995; player.vel.z *= 0.9995;
  }

  player.vel.y += GRAV * dt;
  const next = player.pos.clone().addScaledVector(player.vel, dt);

  // ground collision top y = 0
  const feet = next.y - player.height/2;
  if (feet < 0){
    next.y = player.height/2;
    if (player.vel.y < 0){ player.vel.x *= 0.993; player.vel.z *= 0.993; }
    player.vel.y = 0; player.onGround = true;
    if ((jumpRequested || jumpBuffer > 0) && input.jumpHeld){
      player.vel.y = player.jumpSpeed; player.onGround = false; jumpRequested=false; jumpBuffer=0;
      player.vel.x *= 1.01; player.vel.z *= 1.01;
    }
  } else player.onGround = false;

  // platform collisions
  const aC = colliderCenter(next), aH = colliderHalf();
  for (const p of platforms){
    const bC = p.mesh.position.clone(), bH = p.half.clone();
    const ov = aabbOverlap(aC,aH,bC,bH);
    if (!ov) continue;
    if (Math.abs(ov.y) > 0){
      next.y += ov.y;
      if (ov.y > 0){ player.vel.y = 0; player.onGround = true; }
      else { player.vel.y = Math.min(0, player.vel.y); }
    } else if (Math.abs(ov.x) > 0){ next.x += ov.x; player.vel.x = 0; }
    else if (Math.abs(ov.z) > 0){ next.z += ov.z; player.vel.z = 0; }
    aC.copy(colliderCenter(next, aC));
  }

  player.pos.copy(next);
  player.vel.x *= 0.999; player.vel.z *= 0.999;
}

/* -------------------------
   Visual smoothing & slerp (snappier)
   ------------------------- */
const qYaw = new THREE.Quaternion(), qPitch = new THREE.Quaternion(), targQ = new THREE.Quaternion();
function updateVisual(dt){
  // position: snappier follow
  const target = player.pos.clone();
  const diff = target.clone().sub(cameraHolder.position);
  const dist = diff.length();
  const maxMove = Math.max(1.0, player.speed * 3.0) * dt;
  if (dist <= maxMove) cameraHolder.position.copy(target);
  else cameraHolder.position.addScaledVector(diff.normalize(), maxMove);

  // rotation: compose yaw * pitch and slerp (less smoothing)
  qYaw.setFromAxisAngle(new THREE.Vector3(0,1,0), yaw);
  qPitch.setFromAxisAngle(new THREE.Vector3(1,0,0), pitch);
  targQ.copy(qYaw).multiply(qPitch);
  cameraHolder.quaternion.slerp(targQ, Math.min(1, 18 * dt));
}

/* -------------------------
   Particle step
   ------------------------- */
function stepParticles(dt){
  pTimer -= dt;
  if (pTimer <= 0){
    const moving = Math.hypot(player.vel.x, player.vel.z) > 0.14;
    if (moving && player.onGround){
      const clusters = Math.random() < 0.25 ? 2 : 1;
      for (let i=0;i<clusters;i++){
        const spread = 1.2;
        const ang = Math.random()*Math.PI*2;
        const r = Math.random()*spread;
        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
        const foot = player.pos.clone().addScaledVector(forward, 0.26);
        foot.y = player.pos.y - player.height/2 + 0.06;
        foot.x += Math.cos(ang)*r; foot.z += Math.sin(ang)*r;
        const vx = (Math.random()-0.5)*0.9, vy = 0.9 + Math.random()*0.6, vz = (Math.random()-0.5)*0.9;
        spawnP(foot.x, foot.y, foot.z, vx, vy, vz, 0.9 + Math.random()*0.6);
      }
    }
    pTimer = pInterval;
  }
  for (let i=0;i<MAX_P;i++){
    if (Plife[i] > 0){
      const pi = i*3;
      Plife[i] -= dt;
      Pvel[pi+1] += GRAV * 0.35 * dt;
      Ppos[pi] += Pvel[pi]*dt;
      Ppos[pi+1] += Pvel[pi+1]*dt;
      Ppos[pi+2] += Pvel[pi+2]*dt;
      if (Plife[i] <= 0) { Ppos[pi]=Ppos[pi+1]=Ppos[pi+2]=9999; }
    }
  }
  pGeo.attributes.position.needsUpdate = true;
  let active=0; for(let i=0;i<MAX_P;i++) if(Plife[i]>0) active++;
  pMat.opacity = THREE.MathUtils.clamp(1 - active/MAX_P * 0.8, 0.22, 1);
}

/* -------------------------
   Main loop
   ------------------------- */
let last = performance.now()/1000;
let fpsC=0, fpsT=0;
function animate(){
  const now = performance.now()/1000;
  let dt = now - last; last = now;
  if (dt > 0.05) dt = 0.05;

  timeOfDay += dt * 0.018; timeOfDay %= 1; updateSun(timeOfDay);

  physicsStep(dt);
  updateVisual(dt);

  // hands: compute state & animate
  computeHandState(dt); // ensures state updated & blending
  updateHands(dt);

  stepParticles(dt);

  renderer.render(scene, camera);

  fpsC++; fpsT += dt;
  if (fpsT >= 0.5){ document.getElementById('fps').textContent = 'FPS: ' + Math.round(fpsC / fpsT); fpsC=0; fpsT=0; }

  requestAnimationFrame(animate);
}
animate();

/* Prevent page scrolling while playing */
window.addEventListener('keydown', (e) => {
  if (document.pointerLockElement === renderer.domElement) {
    if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
  }
});

/* place camera visually at start and keep pitch small */
cameraHolder.position.copy(player.pos);
cameraHolder.quaternion.copy(new THREE.Quaternion());
pitch = 0;

</script>
</body>
</html>
