<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FPS — BHop + Smooth Camera</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; overflow:hidden; background:#000; font-family: Arial, Helvetica, sans-serif; }
    #overlay {
      position:absolute; left:12px; top:12px; z-index:10; color:#fff;
      background: rgba(0,0,0,0.35); padding:10px 12px; border-radius:8px; backdrop-filter: blur(4px);
      transition: opacity .18s;
    }
    #fps { position:absolute; right:12px; top:12px; z-index:10; color:#0f0; background: rgba(0,0,0,0.35); padding:6px 10px; border-radius:8px; font-family:monospace; }
    #crosshair {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 9;
      width: 18px; height: 18px; pointer-events: none;
    }
    #crosshair:before, #crosshair:after {
      content: ""; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      width: 2px; height: 10px; background: rgba(255,255,255,0.9);
    }
    #crosshair:after { transform: translate(-50%, -50%) rotate(90deg); }
    #hint { font-size:13px; line-height:1.3; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="overlay">
    <div style="font-weight:700">FPS — BHop + Smooth Camera</div>
    <div id="hint">Click to lock pointer. Move: W A S D · Jump: Space · Run: Shift · BHop-ready</div>
  </div>
  <div id="fps">FPS: --</div>
  <div id="crosshair"></div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';

/* ===========================
   Renderer & Scene
   =========================== */
const scene = new THREE.Scene();
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.4)); // cap DPR for perf
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* Camera hierarchy (visual) */
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
const yawObject = new THREE.Object3D();
const pitchObject = new THREE.Object3D();
pitchObject.add(camera);
yawObject.add(pitchObject);
scene.add(yawObject);

window.addEventListener('resize', ()=> {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ===========================
   Lighting, sun & moon visuals
   =========================== */
const hemi = new THREE.HemisphereLight(0x87ceeb, 0x222244, 0.6);
scene.add(hemi);

const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(512,512);
sunLight.shadow.camera.near = 0.5; sunLight.shadow.camera.far = 300;
sunLight.shadow.camera.left = -60; sunLight.shadow.camera.right = 60;
sunLight.shadow.camera.top = 60; sunLight.shadow.camera.bottom = -60;
scene.add(sunLight);

// visible sun & moon
const sunMesh = new THREE.Mesh(new THREE.SphereGeometry(1.6, 12, 8), new THREE.MeshBasicMaterial({ color:0xfff0c8, toneMapped:false }));
const moonMesh = new THREE.Mesh(new THREE.SphereGeometry(1.2, 10, 8), new THREE.MeshBasicMaterial({ color:0xdde6ff, toneMapped:false }));
scene.add(sunMesh, moonMesh);

/* ===========================
   World: ground, platforms
   =========================== */
const world = new THREE.Group(); scene.add(world);
const ground = new THREE.Mesh(new THREE.BoxGeometry(500,1,500), new THREE.MeshStandardMaterial({ color:0x445544 }));
ground.receiveShadow = true; ground.position.y = -0.5; world.add(ground);

const platforms = [];
function makePlatform(x,y,z,sx=6,sy=1,sz=6,color=0x8b7d6b){
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), new THREE.MeshStandardMaterial({ color }));
  mesh.position.set(x,y,z); mesh.castShadow = true; mesh.receiveShadow = true;
  world.add(mesh);
  platforms.push({ mesh, half: new THREE.Vector3(sx/2, sy/2, sz/2) });
}
makePlatform(0,2,-10,8,1,8,0x8b7d6b);
makePlatform(12,4,-20,6,1,6,0x7fa0a0);
makePlatform(-12,6,-6,4,1,10,0x6a8b8b);

/* Decorative instanced boxes (efficient) */
const decoCount = 36;
const boxGeo = new THREE.BoxGeometry(1,1,1);
const boxMat = new THREE.MeshStandardMaterial({ color:0x8a9a9a });
const inst = new THREE.InstancedMesh(boxGeo, boxMat, decoCount);
inst.castShadow = true; inst.receiveShadow = true;
const dummy = new THREE.Object3D();
for (let i=0;i<decoCount;i++){
  const s = 0.6 + Math.random()*2.4;
  dummy.scale.set(s,s,s);
  dummy.position.set((Math.random()-0.5)*120, s/2, (Math.random()-0.5)*120);
  dummy.updateMatrix();
  inst.setMatrixAt(i, dummy.matrix);
  platforms.push({ mesh: { position: dummy.position.clone() }, half: new THREE.Vector3(s/2, s/2, s/2) });
}
world.add(inst);

/* ===========================
   Player data (physics collider separate from visual camera)
   =========================== */
const player = {
  height: 1.8,
  radius: 0.35,
  velocity: new THREE.Vector3(),
  speed: 6,
  runMultiplier: 1.8,
  jumpSpeed: 7.2,
  onGround: false,
  pos: new THREE.Vector3(0, 1.8, 10), // physics collider position (center bottom at pos.y - height/2)
};

// camera visual follows this collider but smoothed/clamped to avoid snaps
yawObject.position.copy(player.pos);

/* collider helpers */
function centerFromPos(pos, out=new THREE.Vector3()){
  return out.set(pos.x, pos.y - (player.height/2 - player.radius), pos.z);
}
function halfVec(){ return new THREE.Vector3(player.radius, player.height/2, player.radius); }

/* AABB overlap test */
function aabbOverlap(aCenter, aHalf, bCenter, bHalf){
  const dx = aCenter.x - bCenter.x; const px = (aHalf.x + bHalf.x) - Math.abs(dx);
  if (px <= 0) return null;
  const dy = aCenter.y - bCenter.y; const py = (aHalf.y + bHalf.y) - Math.abs(dy);
  if (py <= 0) return null;
  const dz = aCenter.z - bCenter.z; const pz = (aHalf.z + bHalf.z) - Math.abs(dz);
  if (pz <= 0) return null;
  const overlap = new THREE.Vector3();
  if (px < py && px < pz) overlap.x = dx > 0 ? px : -px;
  else if (py < px && py < pz) overlap.y = dy > 0 ? py : -py;
  else overlap.z = dz > 0 ? pz : -pz;
  return overlap;
}

/* ===========================
   Controls & pointer lock
   =========================== */
const input = { forward:0, backward:0, left:0, right:0, run:0, jump:0 };
window.addEventListener('keydown', e=>{
  if (e.code==='KeyW') input.forward=1;
  if (e.code==='KeyS') input.backward=1;
  if (e.code==='KeyA') input.left=1;
  if (e.code==='KeyD') input.right=1;
  if (e.code==='ShiftLeft' || e.code==='ShiftRight') input.run=1;
  if (e.code==='Space') input.jump=1;
});
window.addEventListener('keyup', e=>{
  if (e.code==='KeyW') input.forward=0;
  if (e.code==='KeyS') input.backward=0;
  if (e.code==='KeyA') input.left=0;
  if (e.code==='KeyD') input.right=0;
  if (e.code==='ShiftLeft' || e.code==='ShiftRight') input.run=0;
  if (e.code==='Space') input.jump=0;
});

let pointerEnabled=false;
const PI_2 = Math.PI/2;
const sensitivity = 0.0021;
document.addEventListener('mousemove', e=>{
  if (!pointerEnabled) return;
  yawObject.rotation.y -= e.movementX * sensitivity;
  pitchObject.rotation.x -= e.movementY * sensitivity;
  pitchObject.rotation.x = Math.max(-PI_2+0.005, Math.min(PI_2-0.005, pitchObject.rotation.x));
});
renderer.domElement.addEventListener('click', ()=> renderer.domElement.requestPointerLock?.());
document.addEventListener('pointerlockchange', ()=> {
  pointerEnabled = document.pointerLockElement === renderer.domElement;
  document.getElementById('overlay').style.opacity = pointerEnabled ? '0.6' : '1';
});
window.addEventListener('keydown', e=>{
  const keys = ['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'];
  if (keys.includes(e.code) && document.pointerLockElement === renderer.domElement) e.preventDefault();
});

/* ===========================
   BHop: air acceleration & jump buffering
   =========================== */
let jumpRequested = false;
let jumpBufferTime = 0;
const maxJumpBuffer = 0.14; // seconds
window.addEventListener('keydown', e=> {
  if (e.code === 'Space') { jumpRequested = true; jumpBufferTime = maxJumpBuffer; }
});
window.addEventListener('keyup', e=> {
  if (e.code === 'Space') jumpRequested = false;
});

/* ===========================
   Particle system (pooled)
   =========================== */
const maxParticles = 96;
const particlePositions = new Float32Array(maxParticles*3);
const particleLives = new Float32Array(maxParticles);
const particleVels = new Float32Array(maxParticles*3);
const particleGeo = new THREE.BufferGeometry();
particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
const particleMat = new THREE.PointsMaterial({ size: 0.08, transparent:true, opacity:0.9, depthWrite:false });
const particleSys = new THREE.Points(particleGeo, particleMat);
particleSys.frustumCulled = false;
scene.add(particleSys);

function spawnParticle(x,y,z, vx,vy,vz, life=0.9){
  for (let i=0;i<maxParticles;i++){
    if (particleLives[i] <= 0){
      const pi = i*3;
      particlePositions[pi]=x; particlePositions[pi+1]=y; particlePositions[pi+2]=z;
      particleVels[pi]=vx; particleVels[pi+1]=vy; particleVels[pi+2]=vz;
      particleLives[i]=life;
      return;
    }
  }
}

/* spawn throttle for particles (less frequent than before) */
let particleTimer = 0;
const particleSpawnInterval = 0.14; // seconds between clusters

/* helper: sample foot position and spread */
function footPositionSpread(radius=0.8){
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  const foot = player.pos.clone().addScaledVector(forward, 0.25);
  // put at approximate feet level
  foot.y = player.pos.y - player.height/2 + 0.05;
  // spread randomly in a larger area
  const angle = Math.random() * Math.PI * 2;
  const r = Math.random() * radius;
  foot.x += Math.cos(angle) * r;
  foot.z += Math.sin(angle) * r;
  return foot;
}

/* ===========================
   Blocky hands (camera child) + smoother bob
   =========================== */
const handGroup = new THREE.Object3D();
camera.add(handGroup);
// improved initial offset (closer to camera, more stable)
handGroup.position.set(0.28, -0.28, -0.48);

const armMat = new THREE.MeshStandardMaterial({ color:0xd6b07a });
const leftHand = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.22,0.44), armMat);
const rightHand = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.22,0.44), armMat);
leftHand.position.set(-0.40, 0, 0.05); rightHand.position.set(0.40, 0, 0.05);
leftHand.castShadow = rightHand.castShadow = true;
handGroup.add(leftHand, rightHand);

// hand smoothing state
let handBobPhase = 0;
let smoothedSpeed = 0;
const handLerp = 0.14; // how quickly hands follow target bob

/* ===========================
   Sun/Moon update
   =========================== */
let timeOfDay = 0.32;
function updateSunMoon(t){
  const angle = t * Math.PI * 2;
  const sunDir = new THREE.Vector3(Math.cos(angle), Math.sin(angle), Math.sin(angle*0.6)).normalize();
  const sunPos = sunDir.clone().multiplyScalar(120);
  sunLight.position.copy(sunPos);
  sunLight.target.position.set(0,0,0); sunLight.target.updateMatrixWorld();
  sunMesh.position.copy(sunPos);
  moonMesh.position.copy(sunDir.clone().multiplyScalar(-80));
  const sunBrightness = Math.max(0.12, Math.sin(angle)*0.95);
  hemi.intensity = THREE.MathUtils.lerp(0.08, 0.9, Math.max(0, sunBrightness));
  sunLight.intensity = THREE.MathUtils.lerp(0.15, 1.4, Math.max(0, Math.sin(angle)));
  const dayColor = new THREE.Color(0x87ceeb), nightColor = new THREE.Color(0x0b1220);
  const factor = THREE.MathUtils.smoothstep(Math.sin(angle), -0.2, 0.6);
  renderer.setClearColor(nightColor.clone().lerp(dayColor, factor));
}

/* ===========================
   Physics: ground & platforms collisions + bhop-friendly air control
   =========================== */
const gravity = -20.0;
const groundTopY = 0; // ground top y = 0 (ground mesh top)
function physicsStep(dt){
  // -- Jump buffering countdown
  if (jumpBufferTime > 0) jumpBufferTime -= dt;

  // Movement input
  const forward = input.forward - input.backward;
  const strafe = input.right - input.left;
  const run = input.run ? player.runMultiplier : 1;
  const wishSpeed = player.speed * run;

  // orientation yaw only
  const euler = new THREE.Euler(0, yawObject.rotation.y, 0, 'YXZ');
  const forwardVec = new THREE.Vector3(0,0,-1).applyEuler(euler).setY(0).normalize();
  const rightVec = new THREE.Vector3(1,0,0).applyEuler(euler).setY(0).normalize();

  // desired horizontal vector
  const wish = new THREE.Vector3();
  wish.addScaledVector(forwardVec, forward);
  wish.addScaledVector(rightVec, strafe);
  if (wish.lengthSq() > 0) wish.normalize();

  // apply different handling on ground vs air
  if (player.onGround){
    // ground friction: if no input, slow down fast
    const stopFactor = Math.max(0.0, 1 - Math.min(1, 10 * dt));
    player.velocity.x *= stopFactor;
    player.velocity.z *= stopFactor;

    // accelerate on the ground
    if (wish.lengthSq() > 0){
      const targetVX = wish.x * wishSpeed;
      const targetVZ = wish.z * wishSpeed;
      // immediate-ish ground accel for responsiveness
      player.velocity.x = THREE.MathUtils.lerp(player.velocity.x, targetVX, Math.min(1, 20 * dt));
      player.velocity.z = THREE.MathUtils.lerp(player.velocity.z, targetVZ, Math.min(1, 20 * dt));
    }

    // Jump execution (take into account jump buffer)
    if ((jumpRequested || jumpBufferTime > 0) && player.onGround){
      player.velocity.y = player.jumpSpeed;
      player.onGround = false;
      jumpRequested = false;
      jumpBufferTime = 0;
    }
  } else {
    // IN AIR: apply air acceleration (bhop-able)
    const airAccel = 8.5; // tweak: larger means stronger control in air
    if (wish.lengthSq() > 0){
      // project current horizontal velocity onto wish direction
      const horiz = new THREE.Vector3(player.velocity.x, 0, player.velocity.z);
      const currentSpeed = horiz.dot(wish);
      const addSpeed = (wishSpeed - currentSpeed);
      if (addSpeed > 0){
        const accel = Math.min(addSpeed, airAccel * dt);
        player.velocity.x += wish.x * accel;
        player.velocity.z += wish.z * accel;
      }
      // subtle air-strafe: allow small perpendicular acceleration when strafing & turning
      const sideAccelFactor = 1.2;
      player.velocity.x += wish.x * 0.0; // kept small to avoid drifting explosion
      // cap horizontal air speed to some limit (prevents runaway)
      const horizSpeed = Math.sqrt(player.velocity.x*player.velocity.x + player.velocity.z*player.velocity.z);
      const maxAirSpeed = Math.max(wishSpeed * 1.1, player.speed * 1.6);
      if (horizSpeed > maxAirSpeed){
        const scale = maxAirSpeed / horizSpeed;
        player.velocity.x *= scale; player.velocity.z *= scale;
      }
    }
    // allow jump buffer to queue next jump: if buffer and very close to ground (coyote), we'll execute in landing code
  }

  // gravity always
  player.velocity.y += gravity * dt;

  // integrate to tentative next pos
  const nextPos = player.pos.clone().addScaledVector(player.velocity, dt);

  // simple floor collision
  const feetY = nextPos.y - player.height/2;
  if (feetY < groundTopY){
    // landed
    nextPos.y = player.height/2 + groundTopY;
    if (player.velocity.y < 0) {
      // preserve horizontal speed when landing to allow bhop chaining
      // small landing friction: reduce a fraction only to make bhop possible
      player.velocity.x *= 0.98;
      player.velocity.z *= 0.98;
    }
    player.velocity.y = 0;
    player.onGround = true;
    // if jump was requested while in air (buffer), auto-jump on landing (bhop assist)
    if (jumpRequested || jumpBufferTime > 0){
      player.velocity.y = player.jumpSpeed;
      player.onGround = false;
      jumpRequested = false;
      jumpBufferTime = 0;
      // small extra horizontal preserve so skillful chaining works
      player.velocity.x *= 1.01;
      player.velocity.z *= 1.01;
    }
  } else {
    player.onGround = false;
  }

  // AABB collision with platforms
  const aCenter = centerFromPos(nextPos);
  const aHalf = halfVec();
  for (const p of platforms){
    const bCenter = p.mesh.position.clone();
    const bHalf = p.half.clone();
    const overlap = aabbOverlap(aCenter, aHalf, bCenter, bHalf);
    if (!overlap) continue;
    // resolve smallest axis
    if (Math.abs(overlap.y) > 0){
      nextPos.y += overlap.y;
      if (overlap.y > 0){
        // landed on top of platform
        player.velocity.y = 0; player.onGround = true;
      } else {
        // hit head
        player.velocity.y = Math.min(0, player.velocity.y);
      }
    } else if (Math.abs(overlap.x) > 0){
      nextPos.x += overlap.x;
      player.velocity.x = 0;
    } else if (Math.abs(overlap.z) > 0){
      nextPos.z += overlap.z;
      player.velocity.z = 0;
    }
    // recalc center after resolution (important for multiple collisions)
    aCenter.copy(centerFromPos(nextPos, aCenter));
  }

  // apply final physics position
  player.pos.copy(nextPos);

  // slight horizontal damping to avoid infinite sliding
  player.velocity.x *= 0.999;
  player.velocity.z *= 0.999;
}

/* ===========================
   Camera smoothing (prevents snap -> "glitch" when collisions resolve)
   =========================== */
/* We'll smoothly move the visual yawObject to the collider, but cap the max movement per frame.
   That ensures collision corrections don't instantly teleport your view or flip perspective. */
function updateVisualFromPhysics(dt){
  // maximum allowed camera visual move per frame (prevents instant large snaps)
  const maxMove = Math.max(0.6, player.speed * 2.2) * dt; // meters per frame cap
  const to = player.pos.clone();
  const diff = to.clone().sub(yawObject.position);
  const dist = diff.length();
  if (dist <= maxMove){
    yawObject.position.copy(to);
  } else {
    yawObject.position.addScaledVector(diff.normalize(), maxMove);
  }
}

/* ===========================
   Particles update
   =========================== */
function updateParticles(dt){
  particleTimer -= dt;
  if (particleTimer <= 0){
    // spawn cluster only if moving and on ground (less frequent)
    const moving = (Math.abs(player.velocity.x) > 0.15 || Math.abs(player.velocity.z) > 0.15);
    if (moving && player.onGround){
      // spawn 1-2 particles over larger area
      const clusterCount = Math.random() < 0.3 ? 2 : 1;
      for (let i=0;i<clusterCount;i++){
        const foot = footPositionSpread(0.9);
        const vx = (Math.random()-0.5)*0.8;
        const vy = 0.8 + Math.random()*0.6;
        const vz = (Math.random()-0.5)*0.8;
        spawnParticle(foot.x, foot.y, foot.z, vx, vy, vz, 0.9 + Math.random()*0.5);
      }
    }
    particleTimer = particleSpawnInterval;
  }
  // simulate particles
  for (let i=0;i<maxParticles;i++){
    if (particleLives[i] > 0){
      const pi = i*3;
      particleLives[i] -= dt;
      particleVels[pi+1] += gravity * 0.35 * dt;
      particlePositions[pi] += particleVels[pi]*dt;
      particlePositions[pi+1] += particleVels[pi+1]*dt;
      particlePositions[pi+2] += particleVels[pi+2]*dt;
      if (particleLives[i] <= 0) {
        particlePositions[pi]=particlePositions[pi+1]=particlePositions[pi+2]=9999;
      }
    }
  }
  particleGeo.attributes.position.needsUpdate = true;
  // fade based on activity (cheap)
  let active = 0;
  for (let i=0;i<maxParticles;i++) if (particleLives[i] > 0) active++;
  particleMat.opacity = THREE.MathUtils.clamp(1 - active/maxParticles*0.6, 0.28, 1);
}

/* helper to compute foot position for particles */
function footPositionSpread(radius=0.9){
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  const foot = player.pos.clone().addScaledVector(forward, 0.25);
  foot.y = player.pos.y - player.height/2 + 0.06;
  const angle = Math.random()*Math.PI*2;
  const r = Math.random()*radius;
  foot.x += Math.cos(angle)*r; foot.z += Math.sin(angle)*r;
  return foot;
}

/* ===========================
   Hands bob smoothing & update
   =========================== */
function updateHands(dt){
  // smoothed speed for bob
  const horizontalSpeed = Math.sqrt(player.velocity.x*player.velocity.x + player.velocity.z*player.velocity.z);
  smoothedSpeed = THREE.MathUtils.lerp(smoothedSpeed, horizontalSpeed, 0.08);
  // bob frequency & amplitude mapped to speed
  const baseSpeed = player.speed;
  const bobFreq = THREE.MathUtils.lerp(1.2, 9.0, Math.min(1, smoothedSpeed / (baseSpeed*1.0)));
  handBobPhase += dt * bobFreq * 6.0;
  const bobAmount = Math.min(0.04, smoothedSpeed * 0.0035);
  // target transforms
  const tx = 0.28 + Math.sin(handBobPhase * 0.5) * bobAmount * 0.6;
  const ty = -0.28 + Math.sin(handBobPhase) * bobAmount;
  const rz = Math.sin(handBobPhase * 0.9) * bobAmount * 0.6;
  // lerp to target (smooth)
  handGroup.position.x = THREE.MathUtils.lerp(handGroup.position.x, tx, handLerp);
  handGroup.position.y = THREE.MathUtils.lerp(handGroup.position.y, ty, handLerp);
  handGroup.rotation.x = THREE.MathUtils.lerp(handGroup.rotation.x, rz, handLerp*0.8);
  // small independent finger sway for subtlety (left/right)
  leftHand.rotation.z = THREE.MathUtils.lerp(leftHand.rotation.z, Math.sin(handBobPhase*0.8)*0.06, 0.08);
  rightHand.rotation.z = THREE.MathUtils.lerp(rightHand.rotation.z, Math.cos(handBobPhase*0.8)*0.06, 0.08);
}

/* ===========================
   Main loop
   =========================== */
let last = performance.now()/1000;
let fpsFrames = 0, fpsTime = 0;
function animate(){
  const now = performance.now()/1000;
  let dt = now - last; last = now;
  if (dt > 0.05) dt = 0.05;

  // advance day
  timeOfDay += dt * 0.018;
  timeOfDay %= 1;
  updateSunMoon(timeOfDay);

  // physics
  physicsStep(dt);

  // smoothly move visual camera to physics collider
  updateVisualFromPhysics(dt);

  // update particles and spawn throttle
  updateParticles(dt);

  // hands update
  updateHands(dt);

  // render
  renderer.render(scene, camera);

  // fps
  fpsFrames++; fpsTime += dt;
  if (fpsTime >= 0.5){
    const fps = Math.round(fpsFrames / fpsTime);
    document.getElementById('fps').textContent = 'FPS: ' + fps;
    fpsFrames = 0; fpsTime = 0;
  }

  requestAnimationFrame(animate);
}
animate();

</script>
</body>
</html>
